# Контекст
Компонент уже описан в ООП стиле

# Проблема
Каждый компонент не статичен. Он живой. И постоянно изменяет свое состояние

# Цикл жизни компонента
- Создание класса, который описывает DOM-компонент:
  - Регистрация данных (тип, данные, с которыми он работает, начальное состояние)
  - Рендеринг
  - Генерация DOM на основе шаблона (Virtual DOM, <template />, шаблонная строка, отдельный файл)
  - Вставка полученного DOM на страницу
  - Добавление обработчиков событий после рендеринга
  - ... (ререндеринг из-за изменения внутреннего состояния)
  - Уход из DOM дерева
  - Удаление вообще из памяти

# ...
# Изменение внутреннего состояния компонента по ходу его жизни (пока он еще отрисован)
- Когда мы создаем объект, который описывает UI-компонент, у него есть
  - внешние параметры (аналог props из React) — параметры с которыми инициализируется компонент
  - внутреннее состояние (аналог state из React) — значения, которые
    - инкапсулированы (хотя бы частично) внутри компонента
    - изменяются благодаря логике, которая содержится внутри компонента

Когда компонент зависит только от внешних данных, логика рендера линейна:
```
(props) => DOM
```

Когда у UI компонента появляется внутреннее состояние, появляется запрос на следующее поведение
```
(props + state) => DOM -[Events]-> state => DOM
```
- Изменение внутреннего состояния обновляет DOM
  - Тикание таймера
  - Приход данных по сети
- Изменение DOM обновляет внутреннее состояние
  - Пользовательский ввод

Единственная сложность в обеспечении этой взаимосвязи: эффективное обновление
- бесконечный цикл зависимости состояния от DOM
- точечные обновления
  - точечные обновления DOM-дерева
    - минимизация повторных отрисовок
    - сохранение контекстов
      - наличие обработчиков событий
      - сохранение внутреннего состояния

Задача эффективного обновления DOM очень сложна. Причем ее сложность вырастает кратно с увеличением DOM. Для решения этой задачи существуют инструменты, которые долго и эффективно развиваются
> Вывод: чем сложнее задача частичного обновления DOM тем сложнее шаблонизатор

- Шаблонизаторы становятся декларативными
  > Императивный стиль описывает "как сделать" (подробное описание каждого шага)
  > Декларативный стиль описывает желаемый результат, без уточнения механизма работы

  > Шаблоны — декларативны. Но язык HTML это тоже декларативный язык. И как правило языки шаблонов становятся очень близки по синтаксису к HTML. Важно помнить, что они таковым не являются (JSX это не HTML, это способ описать дерево вызовов функций, ангуляровские шаблоны это не HTML, это способ описать дерево компонент)

- Шаблонизатор будет содержать некий "Язык программирования", который описывает инструкции
  - чтение данных => как при первом рендеринге, так и при повторных
  - условные операторы
  - циклы
  - обработчики событий => имеют привязку к состоянию с возможностью его изменить

```
[Component]        [Template]
  [Data]     ==>      [DOM]
  [Data]     <==      [DOM]
          two-way data
            binding
```

# Angular и его особенности
- Компоненты описываются как обычные классы, которые ниоткуда не наследуются
- Для пометки компонента как класса Ангуляр использует TypeScript механизм, который называется декоратор
  - Это значит, что Ангуляр работает только с TypeScript
- Для расширения возможностей стандартных классов используются интерфейсы. Если компонент будет отчуждаем и нам нужен метод, который описывает удаление его из DOM, мы имплементируем интерфейс onDestroy, встроенный в Angular

> *Существует отдельная библиотека, которая называется AngularJS, но это не Angular. Это развитие библиотеки Angular 1.0, упор в которой делался на паттерн в программировании, который называется MVVM (Model View ViewModel). Но с появлением Angular 2.0, библиотека сделала поворот в своем равитии и теперь она не похожа на AngularJS.
